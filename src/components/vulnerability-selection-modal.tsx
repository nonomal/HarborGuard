'use client';

import { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2 } from 'lucide-react';

interface Vulnerability {
  id: string;
  cveId: string;
  packageName: string;
  currentVersion: string;
  fixedVersion: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  packageManager: string;
}

interface VulnerabilityGroup {
  packageManager: string;
  vulnerabilities: Vulnerability[];
}

interface VulnerabilitySelectionModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  scanId: string;
  imageName: string;
  imageTag: string;
  onConfirm: (selectedVulnerabilities: string[], newImageName: string, newImageTag: string) => void;
}

export function VulnerabilitySelectionModal({
  open,
  onOpenChange,
  scanId,
  imageName,
  imageTag,
  onConfirm,
}: VulnerabilitySelectionModalProps) {
  const [loading, setLoading] = useState(true);
  const [vulnerabilities, setVulnerabilities] = useState<VulnerabilityGroup[]>([]);
  const [selectedVulns, setSelectedVulns] = useState<Set<string>>(new Set());
  const [selectAll, setSelectAll] = useState(true);
  const [newImageName, setNewImageName] = useState(imageName);
  const [newImageTag, setNewImageTag] = useState('');

    useEffect(() => {
      if (open && scanId) {
        fetchPatchableVulnerabilities();
        // Set default values when modal opens
        setNewImageName(decodeURIComponent(imageName));
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        setNewImageTag(`patched-${timestamp}`);
      }
    }, [open, scanId, imageName]);

  const fetchPatchableVulnerabilities = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/patches/analyze?scanId=${scanId}`);
      const data = await response.json();
      
      if (data.analysis) {
        const groups: VulnerabilityGroup[] = [];
        
        // Group vulnerabilities by package manager
        for (const [packageManager, vulnData] of Object.entries(data.analysis.byPackageManager)) {
          const pmData = vulnData as any;
          const vulns: Vulnerability[] = [];
          
          if (pmData.vulnerabilities) {
            for (const vuln of pmData.vulnerabilities) {
              vulns.push({
                id: vuln.id,
                cveId: vuln.cveId,
                packageName: vuln.packageName,
                currentVersion: vuln.currentVersion,
                fixedVersion: vuln.fixedVersion,
                severity: vuln.severity,
                packageManager,
              });
            }
          }
          
          if (vulns.length > 0) {
            groups.push({
              packageManager,
              vulnerabilities: vulns.sort((a, b) => {
                const severityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
                return severityOrder[a.severity] - severityOrder[b.severity];
              }),
            });
          }
        }
        
        setVulnerabilities(groups);
        
        // Select all by default
        const allVulnIds = groups.flatMap(g => g.vulnerabilities.map(v => v.id));
        setSelectedVulns(new Set(allVulnIds));
      }
    } catch (error) {
      console.error('Failed to fetch patchable vulnerabilities:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectAll = () => {
    if (selectAll) {
      setSelectedVulns(new Set());
    } else {
      const allVulnIds = vulnerabilities.flatMap(g => g.vulnerabilities.map(v => v.id));
      setSelectedVulns(new Set(allVulnIds));
    }
    setSelectAll(!selectAll);
  };

  const handleToggleVulnerability = (vulnId: string) => {
    const newSelected = new Set(selectedVulns);
    if (newSelected.has(vulnId)) {
      newSelected.delete(vulnId);
    } else {
      newSelected.add(vulnId);
    }
    setSelectedVulns(newSelected);
    
    // Update select all state
    const allVulnIds = vulnerabilities.flatMap(g => g.vulnerabilities.map(v => v.id));
    setSelectAll(newSelected.size === allVulnIds.length);
  };

  const handleTogglePackageManager = (packageManager: string) => {
    const group = vulnerabilities.find(g => g.packageManager === packageManager);
    if (!group) return;
    
    const groupVulnIds = group.vulnerabilities.map(v => v.id);
    const allSelected = groupVulnIds.every(id => selectedVulns.has(id));
    
    const newSelected = new Set(selectedVulns);
    if (allSelected) {
      groupVulnIds.forEach(id => newSelected.delete(id));
    } else {
      groupVulnIds.forEach(id => newSelected.add(id));
    }
    setSelectedVulns(newSelected);
    
    // Update select all state
    const allVulnIds = vulnerabilities.flatMap(g => g.vulnerabilities.map(v => v.id));
    setSelectAll(newSelected.size === allVulnIds.length);
  };

  const handleConfirm = () => {
    onConfirm(Array.from(selectedVulns), newImageName, newImageTag);
    onOpenChange(false);
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'CRITICAL':
        return 'bg-red-500';
      case 'HIGH':
        return 'bg-orange-500';
      case 'MEDIUM':
        return 'bg-yellow-500';
      case 'LOW':
        return 'bg-blue-500';
      default:
        return 'bg-gray-500';
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle>Select Vulnerabilities to Patch</DialogTitle>
          <DialogDescription>
            Choose which vulnerabilities you want to patch. Vulnerabilities are grouped by package manager.
          </DialogDescription>
        </DialogHeader>

        {loading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        ) : (
          <>
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="select-all"
                  checked={selectAll}
                  onCheckedChange={handleSelectAll}
                />
                <label
                  htmlFor="select-all"
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                >
                  Select All ({selectedVulns.size} selected)
                </label>
              </div>
            </div>

            <ScrollArea className="h-[400px] rounded-md border p-4">
              <div className="space-y-6">
                {vulnerabilities.map((group) => {
                  const groupVulnIds = group.vulnerabilities.map(v => v.id);
                  const groupSelected = groupVulnIds.filter(id => selectedVulns.has(id)).length;
                  const allGroupSelected = groupSelected === groupVulnIds.length;

                  return (
                    <div key={group.packageManager} className="space-y-2">
                      <div className="flex items-center justify-between border-b pb-2">
                        <div className="flex items-center space-x-2">
                          <Checkbox
                            id={`pm-${group.packageManager}`}
                            checked={allGroupSelected}
                            onCheckedChange={() => handleTogglePackageManager(group.packageManager)}
                          />
                          <label
                            htmlFor={`pm-${group.packageManager}`}
                            className="text-sm font-semibold"
                          >
                            {group.packageManager.toUpperCase()} ({groupSelected}/{group.vulnerabilities.length})
                          </label>
                        </div>
                      </div>

                      <div className="space-y-2 pl-6">
                        {group.vulnerabilities.map((vuln) => (
                          <div
                            key={vuln.id}
                            className="flex items-center space-x-2 py-1"
                          >
                            <Checkbox
                              id={vuln.id}
                              checked={selectedVulns.has(vuln.id)}
                              onCheckedChange={() => handleToggleVulnerability(vuln.id)}
                            />
                            <label
                              htmlFor={vuln.id}
                              className="flex-1 text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
                            >
                              <div className="flex items-center gap-2">
                                <Badge className={getSeverityColor(vuln.severity)}>
                                  {vuln.severity}
                                </Badge>
                                <span className="font-mono text-xs">{vuln.cveId}</span>
                                <span className="text-muted-foreground">
                                  {vuln.packageName} ({vuln.currentVersion} â†’ {vuln.fixedVersion})
                                </span>
                              </div>
                            </label>
                          </div>
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </ScrollArea>

            <div className="space-y-4 border-t pt-4">
              <div className="grid gap-2">
                <Label htmlFor="image-name">New Image Name</Label>
                <Input
                  id="image-name"
                  value={newImageName}
                  onChange={(e) => setNewImageName(e.target.value)}
                  placeholder={decodeURIComponent(imageName)}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="image-tag">New Image Tag</Label>
                <Input
                  id="image-tag"
                  value={newImageTag}
                  onChange={(e) => setNewImageTag(e.target.value)}
                  placeholder="patched-YYYY-MM-DD-HH-mm-ss"
                />
              </div>
            </div>
          </>
        )}

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button 
            onClick={handleConfirm} 
            disabled={selectedVulns.size === 0 || loading}
          >
            Patch Selected ({selectedVulns.size})
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
